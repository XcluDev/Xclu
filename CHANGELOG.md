Xclu: Changelog 

----
Добавилась схема для финальной сборки Выпуск-Deploy - которая берет файлы из xclu.qrc 
Сделать загрузку модулей из файловой системы, а не ресурсов - то есть, опцию в .pro. 
А то сейчас много времени на это тратится. 
Начал описывать документацию по API в forum. 
----
Сделать вкладку меню Developer, и там Test module interface... - он позволяет загружать XGUI-файл и переобновлять его без перезагрузки программы. Это позволит полуинтерактивно редактировать GUI модулей и тем самым ускоряет разработку новых модулей. Можно их редактировать в NotePad++ и затем нажимать Reload. 
----
Проверить, что glm::vec3 - если есть векторы, то они инициализируются нулями, если это требуется. 
В таблице модулей чередовать цвета. 
Если названия модулей дублируется в Factory - это не отслеживаеся, исправить.  
Название категорий модулей указывать, заменяя подчеркивание на пробел. 
Определять класс и категорию встроенных модулей по названию папки категории и модуля. 
Развернул форум forum.xclu.dev 
Устранил проблемы - падало при вторичном показе окна, и при использовании VerticalLayout. 
----
Оформил в темной цветовой схеме. 
Сделал сайт на bootstrap - xclu.dev и завел проект на GitHub  
----
Window вызывает при старте IntGui и запрашивает его pointer виджета.   
Делаю WInt - показ целого в окошке. 
Чтобы его поместить - Структура Window, куда он вставляется. И передавать указатель.  
Window - сделал парсинг структуры окна. 
----
например, out(not_save) 
Send_Calls, Accept_Calls в Control модуля - сделать пометку в XGUI, что эти данные не записываются на диск. Так как это может меняться при обновлениях модуля. 
----
Сделать Help-вкладку. Для ускорения загрузки - возможно, стоит кэшировать загруженный help в modulefactory – lazy loader. 
Встроил GLM , лицензия в папке licenses 
Сделать Window - размер и положение. 
----
Сейчас реализована проверка изменений данных с помощью was_changed(). Реализация - как “ленивая” схема проверки того, изменились ли объекты - то есть ,если к объекту обращались с помощью ObjectReadWrite, то считается, что он изменился. А элементы интерфейса - если их int,float или string данные изменились. Это сделано для того, чтобы не наглужать все элементы отслеживать свои изменения, если это не нужно. Зато текущий механизм позволяет не создавать копии данных с интерфейсом в реализации модулей. Теперь можно просто проверить, изменился ли элемент и чдел 

Сделал два объекта - ObjectRead и ObjectReadWrite - первый позволяет только считывать объект, а второй - и писать. 
v. 122. 
----
Окно выбора модуля - поиск по названию, сделать “Search” с полем ввода для запроса. 
----
Это реализовать дополнительной строкой Description 
в int, float, stringlist 
Сделать label справа от элемента - для подписи единиц измерения  
Модули, которые еще не реализованы - делать не bold в списке при добавлении. 
Выбор модулей: вместо tabs сделал слева список категорий, а справа список модулей категории. 
Странслировать в Release. 
----
Но при этом в этом объекте могут быть опциональные параметры, типа громкости. 
Например, SynthFromImage:     add_sound_buffer 
И это показывать на последней вкладке 
описанием названия функции и входного и выходного типа. 
При этом, каждый модуль объявляет, какие функции он обрабатывает,  
Реализовать call(function_name, ErrorInfo, input,output) 
----
При работе с изображениями - перейти на ObjectAccess. 
При создании изображений сделать allocate - чтобы далее можно было самому заполнять массив. 
----
https://doc.qt.io/qt-5/qsoundeffect.html#details 
Воспроизведение 
а также сбор звукового буфера - перечислением через пробел модулей, где получить результат.  
Для этого подключить звуковую систему Qt, и реализовать callbcacks модулей,  
Синтез - https://doc.qt.io/qt-5/qaudiooutput.html 
Реализую звук. https://doc.qt.io/qt-5/audiooverview.html  
----
В модуле добавить заготовку для создания id: module_id_hint=webcam - чтобы было удобнее писать id 
----
Реализую новый механизм режимов работы модуля - без active, и с большим числом вариантов, и с возможность Callback. Реализовал и проверил это в Test. 
----
А так, для всех объектов вывод размера объекта в байтах. 
Реализовать описание объекта - если изображение, то размеры и каналы, 
https://forum.qt.io/topic/67619/insert-image-on-other-qimage-in-qlabel/3 
Показ изображения на Label: 
XcluImage Preview для быстрого построения превью, чтобы выводить на label. 
Конвертация изображения Xclu в QImage и обратно. 
Тип для представления объектов XcluObject. 
Загрузка кадра с камеры. 
Webcamera. 
Делать модули просто по-порядку, выбирая по желанию те, которые уже вписаны. 
----
Кнопки Add,Delete - сейчас занимают очень много места, сделать их иконками в один ряд. 
----
Сделать модуль Execute и на его основе проработать структуру выполняемого модуля - работу с переменными интерфейса, активацию выполения и обработку ошибок. 
Сделал более мягкий контроль ошибок при загрузке проекта - список ошибок выдается в консоли. 
(Подобный механизм можно сделать и для элементов управления, чтобы убрать бесконечные “case” в их конструкторах.) 
Реализации Qt-модулей регистрируют себя автоматически путем размещения вызова макроса REGISTRAR(Имя) в своих CPP-файлах.  
Сделать, чтобы константы не менялись в режиме Run. 
----
Технически, каждый GUI-элемент хранит список тех, кто он него зависит, и при изменении - отправляет сигнал на обновление. Для этого в ModuleInterface собирается список таких связей, и при создании GUI он вставляется в элементы. 
Реализация IF- показ элемента GUI по условию. 
----
Если пользователь изменил модули или переменные - то ставить пометку, что проект изменен. 
Реализовать запись проекта на диск и считывание с диска. 
----
Сделать, чтобы можно было сохранять можно во время выполнения.  
Recent Projects - из примера SDI 
Реализовать кнопки удаления и прочих - работы с модулями. 
Реализовать редактирование Id в параметрах модуля - и проверку его уникальности при запуске. 
----
“Error string” 
“Error checkbox” 
“On error – ignore, message, stop, stop & message” 
Обработка ошибок - добавить в General 
----
Сделать, чтобы во время запуска кнопки редактирования модулей были неактивны. 
Запись и считывание значений в GUI, и реакцию на start/update. Также, запоминаю в интерфейсе модуля tab и положения слайдеров. 
При наведении на Label - показывается имя переменной и описание 
Сделать, чтобы out нельзя было редактировать. 
Показ типа переменной - in,out,const. 
----
Реализация базового вычислительного модуля - RtModule. Он общаетя с Module через ModuleInterface 
Пример SDI 
----
Реализовать хранение настроек проекта, чтобы окно выбора модулей хранило последний выбор. 
Сделать внутреннее имя Id для программирования. 
При ошибке парсинга - генерируется исключение, которое перехватывает FACTORY. 
----
EditorModules наполняется по ModuleInterface. 
ModuleInterface - здесь GUI пропарсенный, невизуальный, с переменными 
ModuleInfo - описание модуля и строки описания GUI, нераспарсенные, из него строится: 
Создание Qt-элементов для классов. 
InterfaceGui - визуальное представление, связанное с переменной. Также, несколько классов. 
InterfaceItem - одна переменная 
----
GUI проходит по этому списку и выстраиваются станицы, а также управление включенностью/выключенностью. 
ModuleInterface - них и переменные, и описание интерфейса. 
Парсинг GUI модуля.  
----
Поэтому при создании нового - имя генерируется. 
Он общается с невизуальным проектом, и тот сообщает, что изменилось - выделенный модуль, или обновился список модулей. У каждого уникальное имя. 
EditorModules 
Редактор списка модулей проекта. 
Project 
Понятие проекта как список модулей и настроек их параметров.  
Показ в виде таблицы 
Module  -  класс модуля, содержащий невизуальный интерфейс (ModuleInterface) и исполнительную часть (RtModule) 
FACTORY - список модулей и генератор новых модулей 
Таблица модулей 
----

